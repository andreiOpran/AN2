- <span style="color:rgb(112, 48, 160)">For the exam, a process with a low number means it has a high priority</span>
- The [[Shortest-Job-First (CPU) Scheduling]] is a special case of the general <span style="color:rgb(112, 48, 160)">priority-scheduling algorithm</span>. A priority is associated with each process, and the CPU is allocated to the process with the highest priority. Equal-priority processes are scheduled in FCFS order. An SJF algorithm is simply a priority algorithm where the priority (p) is the inverse of the (predicted) next CPU burst. The larger the CPU burst, the lower the priority, and vice versa.
- <span style="color:rgb(112, 48, 160)">In this text, we assume that low numbers represent high priority.</span> 
- As an example, consider the following set of processes, assumed to have arrived at time 0 in the order P1, P2, ..., P5, with the length of the CPU burst given in milliseconds:
- ![[Pasted image 20250212023140.png]]
- Using <span style="color:rgb(112, 48, 160)">priority scheduling</span>, we would schedule these processes according to the following <span style="color:rgb(112, 48, 160)">G</span><span style="color:rgb(112, 48, 160)">antt chart</span>:
- ![[Pasted image 20250212023341.png]]
- The <span style="color:rgb(112, 48, 160)">average</span> waiting time is <span style="color:rgb(112, 48, 160)">8.2 milliseconds</span>.

- Priorities can be defined either <span style="color:rgb(112, 48, 160)">internally</span> or <span style="color:rgb(112, 48, 160)">externally</span>. 
	- <span style="color:rgb(112, 48, 160)">Internally</span> <span style="color:rgb(112, 48, 160)">defined priorities</span> use some measurable quantity or quantities to compute the priority of a process. For example, time limits, memory requirements, the number of open files, and the ratio of average I/O burst to average CPU burst have been used in computing priorities. 
	- <span style="color:rgb(112, 48, 160)">External</span> <span style="color:rgb(112, 48, 160)">priorities</span> are set by criteria outside the operating system, such as the importance of the process, the type and amount of funds being paid for computer use, the department sponsoring the work, and other, often political, factors.

- Priority scheduling can be either <span style="color:rgb(112, 48, 160)">preemptive</span> or <span style="color:rgb(112, 48, 160)">nonpreemptive</span>. 
	- When a process arrives at the ready queue, its priority is compared with the priority of the currently running process. 
	- A <span style="color:rgb(112, 48, 160)">preemptive</span> priority scheduling algorithm will preempt the CPU if the priority of the newly arrived process is higher than the priority of the currently running process. 
	- A <span style="color:rgb(112, 48, 160)">nonpreemptive</span> priority scheduling algorithm will simply put the new process at the head of the ready queue.

- A <span style="color:rgb(112, 48, 160)">major problem</span> with <span style="color:rgb(112, 48, 160)">priority scheduling algorithms</span> is <span style="color:rgb(112, 48, 160)">indefinite blocking</span>, or <span style="color:rgb(112, 48, 160)">starvation</span>. 
	- A process that is ready to run but waiting for the CPU can be considered <span style="color:rgb(112, 48, 160)">blocked</span>. A priority scheduling algorithm <span style="color:rgb(112, 48, 160)">can leave some low priority processes waiting indefinitely</span>. In a heavily loaded computer system, a steady stream of higher-priority processes can prevent a low-priority process from ever getting the CPU. 
	- Generally, one of two things will happen: 
		- Either the process will eventually be run (at 2 A.M. Sunday, when the system is finally lightly loaded)
		- Or the computer system will eventually crash and lose all unfinished low-priority processes. (Rumor has it that when they shut down the IBM 7094 at MIT in 1973, they found a low-priority process that had been submitted in 1967 and had not yet been run.)
	- A <span style="color:rgb(112, 48, 160)">solution</span> to the problem of indefinite blockage of low-priority processes is <span style="color:rgb(112, 48, 160)">aging</span>. 
		- <span style="color:rgb(112, 48, 160)">Aging</span> involves gradually increasing the priority of processes that wait in the system for a long time. For example, if priorities range from 127 (low) to 0 (high), we could periodically (say, every second) increase the priority of a waiting process by 1. Eventually, even a process with an initial priority of 127 would have the highest priority in the system and would be executed.
	- <span style="color:rgb(112, 48, 160)">Another option</span> is to combine [[Round-Robin (CPU) Scheduling|round-robin]] and <span style="color:rgb(112, 48, 160)">priority scheduling </span>in such a way that the system executes the highest-priority process and runs processes with the same priority using round-robin scheduling. Letâ€™s illustrate with an example using the following set of processes, with the burst time in milliseconds:
	- ![[Pasted image 20250212025044.png]]
	- Using <span style="color:rgb(112, 48, 160)">priority scheduling</span> with <span style="color:rgb(112, 48, 160)">round-robin</span> for processes with equal priority, we would schedule these processes according to the following <span style="color:rgb(112, 48, 160)">Gantt chart</span> using a <span style="color:rgb(112, 48, 160)">time quantum of 2 milliseconds</span>:
	- ![[Pasted image 20250212025117.png]]
	- In this example, process P4 has the highest priority, so it will run to completion. Processes P2 and P3 have the next-highest priority, and they will execute in a <span style="color:rgb(112, 48, 160)">round-robin </span>fashion. Notice that when process P2 finishes at time 16, process P3 is the highest-priority process, so it will run until it completes execution. Now, only processes P1 and P5 remain, and as they have equal priority, they will execute in round-robin order until they complete.