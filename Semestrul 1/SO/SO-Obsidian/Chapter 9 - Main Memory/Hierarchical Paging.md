
- Most modern computer systems support a large logical address space (2^32 to 2^64). In such an environment, the <span style="color:rgb(112, 48, 160)">page table itself becomes excessively large</span>.
	- For example, consider a system with a 32-bit logical address space. If the page size in such a system is 4 KB (2^12), then a page table may consist of over 1 million entries (2^20 = 2^32 / 2^12). Assuming that each entry consists of 4 bytes, each process may need up to 4 MB of physical address space for the page table alone. Clearly, <span style="color:rgb(112, 48, 160)">we would not want to allocate the page table contiguously in main memory</span>.
	- <span style="color:rgb(112, 48, 160)">One simple solution</span> to this problem is to divide the page table into smaller pieces. We can accomplish this division in several ways.
- <span style="color:rgb(112, 48, 160)">One way</span> is to use a <span style="color:rgb(112, 48, 160)">t</span><span style="color:rgb(112, 48, 160)">wo-level paging algorithm</span>, in which the page table itself is also paged (<span style="color:rgb(112, 48, 160)">Figure 9.15</span>). 
- ![[Pasted image 20250214140042.png]]
- For example, consider again the system with a 32-bit logical address space and a page size of 4 KB. A logical address is divided into a page number consisting of 20 bits and a page offset consisting of 12 bits. Because we page the page table, the page number is further divided into a 10-bit page number and a 10-bit page offset. Thus, a logical address is as follows:
	- ![[Pasted image 20250214135540.png]]
	- where <span style="color:rgb(112, 48, 160)">p1</span> is an index into the outer page table and <span style="color:rgb(112, 48, 160)">p2</span> is the displacement within the page of the inner page table
- The address-translation method for this architecture is shown in <span style="color:rgb(112, 48, 160)">Figure 9.16</span>. Because address translation works from the outer page table inward, this scheme is also known as a <span style="color:rgb(112, 48, 160)">forward-mapped</span> page table.
- ![[Pasted image 20250214140029.png]]
- The outer page table consists of 2^42 entries, or 2^44 bytes. The obvious way to avoid such a large table is to divide the outer page table into smaller pieces.
	- We can divide the outer page table in various ways. For <span style="color:rgb(112, 48, 160)">example</span>, we can page the outer page table, giving us a three-level paging scheme. 
	- Suppose that the outer page table is made up of standard-size pages (2^10 entries, or 2^12 bytes). In this case, a 64-bit address space is still daunting:
	- ![[Pasted image 20250214135902.png]]
	- The outer page table is still 234 bytes (16 GB) in size.
- The next step would be a four-level paging scheme, where the second-level outer page table itself is also paged, and so forth. The 64-bit UltraSPARC would require seven levels of paging—a prohibitive number of memory accesses—to translate each logical address. You can see from this example why, for 64-bit architectures, hierarchical page tables are generally considered inappropriate.