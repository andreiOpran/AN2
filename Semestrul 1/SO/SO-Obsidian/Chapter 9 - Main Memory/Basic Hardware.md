
- Main memory and the registers built into each processing core are the only general-purpose storage that the CPU can access directly. There are machine instructions that take memory addresses as arguments, but none that take disk addresses. Therefore, any instructions in execution, and any data being used by the instructions, must be in one of these direct-access storage devices. If the data are not in memory, they must be moved there before the CPU can operate on them.
- Registers that are built into each CPU core are generally accessible within <span style="color:rgb(112, 48, 160)">one cycle</span> of the CPU clock. Some CPU cores can decode instructions and perform simple operations on register contents at the rate of one or more operations per clock tick.
- The same cannot be said of main memory, which is accessed via a transaction on the memory bus. Completing a memory access may take many cycles of the CPU clock. In such cases, the processor normally needs to <span style="color:rgb(112, 48, 160)">stall</span>, since it does not have the data required to complete the instruction that it is executing. This situation is <span style="color:rgb(112, 48, 160)">intolerable</span> because of the frequency of memory accesses. The remedy is to add fast memory between the CPU and main memory, typically on the CPU chip for fast access. Such a <span style="color:rgb(112, 48, 160)">cache</span> was described in Section 1.5.5. To manage a <span style="color:rgb(112, 48, 160)">cache</span> built into the CPU, the hardware automatically speeds up memory access without any operating-system control. (Recall from Section 5.5.2 that during a memory stall, a multithreaded core can switch from the stalled hardware thread to another hardware thread.)

- Not only are we concerned with the relative speed of accessing physical memory, but we also must ensure <span style="color:rgb(112, 48, 160)">correct operation</span>. For proper system operation, we must <span style="color:rgb(112, 48, 160)">protect the operating system from access by user processes</span>,<span style="color:rgb(112, 48, 160)"></span> as well as <span style="color:rgb(112, 48, 160)">protect user processes from one another</span>. This protection must be <span style="color:rgb(112, 48, 160)">provided by the hardware</span>, because the operating system doesn’t usually intervene between the CPU and its memory accesses (because of the resulting <span style="color:rgb(112, 48, 160)">performance penalty</span>). Hardware implements this production in several different ways, as we show throughout the chapter. Here, we outline one possible implementation.
	- We first need to make sure that each process has a <span style="color:rgb(112, 48, 160)">separate memory space</span>. Separate per-process memory space protects the processes from each other and is fundamental to having multiple processes loaded in memory for concurrent execution. 
	- <span style="color:rgb(112, 48, 160)">To separate memory spaces</span>, we need the ability to determine the range of legal addresses that the process may access and to ensure that the process can access only these legal addresses. We can provide protection by using <span style="color:rgb(112, 48, 160)">two registers</span>, usually a <span style="color:rgb(112, 48, 160)">base</span> and a <span style="color:rgb(112, 48, 160)">limit</span>, as illustrated in Figure 9.1. 
	- ![[Pasted image 20250212193716.png]]
	- The <span style="color:rgb(112, 48, 160)">base</span> register holds the smallest legal physical memory address; the <span style="color:rgb(112, 48, 160)">limit</span> register specifies the size of the range. For example, if the base register holds 300040 and the limit register is 120900, then the program can legally access all addresses from 300040 through <span style="color:rgb(112, 48, 160)">420939</span> (inclusive).
- <span style="color:rgb(112, 48, 160)">Protection of memory space</span> is accomplished by having the CPU hardware compare every address generated in user mode with the registers. Any attempt by a program executing in user mode to access operating-system memory or other users’ memory results in a <span style="color:rgb(112, 48, 160)">trap</span> to the operating system, which treats the attempt as a <span style="color:rgb(112, 48, 160)">fatal error</span> (Figure 9.2). This scheme prevents a user program from (accidentally or deliberately) modifying the code or data structures of either the operating system or other users.
- ![[Pasted image 20250212220732.png]]
- The base and limit registers can be loaded only by the operating system, which uses a special privileged instruction. Since privileged instructions can be executed only in kernel mode, and since only the operating system executes in kernel mode, <span style="color:rgb(112, 48, 160)">only the operating system can load the base and limit registers</span>. This scheme allows the operating system to change the value of the registers but prevents user programs from changing the registers’ contents.
- <span style="color:rgb(112, 48, 160)">The operating system</span>, executing in<span style="color:rgb(112, 48, 160)"> kernel mode</span>, is given <span style="color:rgb(112, 48, 160)">unrestricted access to both operating-system memory and users’ memory</span>. This provision allows the operating system to load users’ programs into users’ memory, to dump out those programs in case of errors, to access and modify parameters of system calls, to perform I/O to and from user memory, and to provide many other services. Consider, for example, that an operating system for a multiprocessing system must execute context switches, storing the state of one process from the registers into main memory before loading the next process’s context from main memory into the registers.