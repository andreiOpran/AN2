
- One approach for handling address spaces larger than 32 bits is to use a <span style="color:rgb(112, 48, 160)">hashed page </span><span style="color:rgb(112, 48, 160)">table</span>, with the hash value being the virtual page number. Each entry in the hash table contains a linked list of elements that hash to the same location (to handle collisions). Each element consists of three fields: (<span style="color:rgb(112, 48, 160)">1</span>) the virtual page number, (<span style="color:rgb(112, 48, 160)">2</span>) the value of the mapped page frame, and (<span style="color:rgb(112, 48, 160)">3</span>) a pointer to the next element in the linked list.
- <span style="color:rgb(112, 48, 160)">The algorithm works as follows</span>: 
	- The virtual page number in the virtual address is hashed into the hash table. 
	- The virtual page number is compared with field 1 in the first element in the linked list. 
	- If there is a match, the corresponding page frame (field 2) is used to form the desired physical address. If there is no match, subsequent entries in the linked list are searched for a matching virtual page number. This scheme is shown in <span style="color:rgb(112, 48, 160)">Figure 9.17</span>.
	- ![[Pasted image 20250214141434.png]]
- A variation of this scheme that is useful for 64-bit address spaces has been proposed. This variation uses <span style="color:rgb(112, 48, 160)">clustered page tables</span>, which are similar to hashed page tables except that each entry in the hash table refers to several pages (such as 16) rather than a single page. Therefore, a single page-table entry can store the mappings for multiple physical-page frames. Clustered page tables are particularly useful for <span style="color:rgb(112, 48, 160)">sparse</span> address spaces, where memory references are noncontiguous and scattered throughout the address space.