
- Memory management discussed thus far has required the physical address space of a process to be contiguous. We now introduce <span style="color:rgb(112, 48, 160)">paging</span>, a memory management scheme that permits a process’s <span style="color:rgb(112, 48, 160)">physical address space to be noncontiguous</span>. Paging <span style="color:rgb(112, 48, 160)">avoids</span> <span style="color:rgb(112, 48, 160)">external fragmentation</span> and the associated need for <span style="color:rgb(112, 48, 160)">compaction</span>, two problems that plague contiguous memory allocation.
- The basic method for implementing paging involves 
	- breaking <span style="color:rgb(112, 48, 160)">physical memory</span> into <span style="color:rgb(112, 48, 160)">fixed-sized blocks</span> called <span style="color:rgb(112, 48, 160)">frames</span> 
	- and breaking <span style="color:rgb(112, 48, 160)">logical memory</span> into blocks of the same size called <span style="color:rgb(112, 48, 160)">pages</span>.
- When a <span style="color:rgb(112, 48, 160)">process is to be executed</span>, its <span style="color:rgb(112, 48, 160)">pages are loaded</span> into any available memory frames from their source (a file system or the backing store). The backing store is divided into fixed-sized blocks that are the<span style="color:rgb(112, 48, 160)"> same size </span>as the memory frames or clusters of multiple frames.
	- For example, the logical address space is now totally separate from the physical address space, so a process can have a logical 64-bit address space even though the system has less than 264 bytes of physical memory
- Every address generated by the CPU is divided into two parts: a <span style="color:rgb(112, 48, 160)">page</span> <span style="color:rgb(112, 48, 160)">number</span> (<span style="color:rgb(112, 48, 160)">p</span>) and a <span style="color:rgb(112, 48, 160)">page</span> <span style="color:rgb(112, 48, 160)">offset</span> (<span style="color:rgb(112, 48, 160)">d</span>):
- ![[Pasted image 20250214114517.png]]
- ![[Pasted image 20250214114531.png]]
- The page number is used as an index into a per-process <span style="color:rgb(112, 48, 160)">page table</span>. This is illustrated in Figure 9.8. The page table contains the base address of each frame in physical memory, and the offset is the location in the frame being referenced. Thus, the base address of the frame is combined with the page offset to define the physical memory address. The paging model of memory is shown in Figure 9.9.
- The <span style="color:rgb(112, 48, 160)">page size</span> (like the frame size) is defined by the hardware. The size of a page is a power of <span style="color: rgb(112, 48, 160)">2</span>, typically varying between 4 KB and 1 GB per page, depending on the computer architecture. The selection of a power of 2 as a page size makes the translation of a logical address into a page number and page offset particularly easy. If the size of the logical address space is 2^m, and a page size is 2^n bytes, then the high-order m−n bits of a logical address designate the page number, and the n low-order bits designate the page offset. Thus, the logical address is as follows:
- ![[Pasted image 20250214115503.png]]
- ![[Pasted image 20250214115510.png]]
	- where p is an index into the page table and d is the displacement within the page.
- The following outlines the steps taken by the <span style="color:rgb(112, 48, 160)">MMU</span> to translate a logical address generated by the CPU to a physical address: 
	1. Extract the page number p and use it as an index into the page table. 
	2. Extract the corresponding frame number f from the page table. 
	3. Replace the page number p in the logical address with the frame number f.

- As a concrete <span style="color:rgb(112, 48, 160)">example</span>, consider the memory in Figure 9.10. Here, in the logical address, n = 2 and m = 4. Using a page size of 4 bytes and a physical memory of 32 bytes (8 pages), we show how the programmer’s view of memory can be mapped into physical memory. Logical address 0 is page 0, offset 0. Indexing into the page table, we find that page 0 is in frame 5. Thus, logical address 0 maps to physical address `20 [= (5 × 4) + 0]`. Logical address 3 (page 0, offset 3) maps to physical address `23 [= (5 × 4) + 3`]. Logical address 4 is page 1, offset 0; according to the page table, page 1 is mapped to frame 6. Thus, logical address 4 maps to physical address `24 [= (6 × 4) + 0]`. Logical address 13 maps to physical address 9.
- ![[Pasted image 20250214120602.png]]
- If process size is independent of page size, we expect internal fragmentation to average one-half page per process. This consideration suggests that small page sizes are desirable. However, overhead is involved in each page table entry, and this overhead is reduced as the size of the pages increases. Also, disk I/O is more efficient when the amount of data being transferred is larger.

- ![[Pasted image 20250214122925.png]]
- Since the operating system is managing physical memory, it must be aware of the allocation details of physical memory—which frames are allocated, which frames are available, how many total frames there are, and so on. This information is generally kept in a single, system-wide data structure called a <span style="color:rgb(112, 48, 160)">frame table</span>. The frame table has one entry for each physical page frame, indicating whether the latter is free or allocated and, if it is allocated, to which page of which process (or processes).