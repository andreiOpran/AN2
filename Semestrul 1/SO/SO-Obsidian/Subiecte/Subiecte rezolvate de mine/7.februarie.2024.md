
---

![[Pasted image 20250216191635.png]]
1 - d
2 - a
3 - e
4 - ~~c~~, de fapt b
5 - f

---

![[Pasted image 20250216191703.png]]

Demand paging: tehnica utilizata in gestionarea memoriei virtuale - paginile de memorie nu sunt incarcate in RAM pana cand nu exista o cerere explicita pentru ele. La inceput, paginile unui proces sunt marcate ca fiind neprezente in tabelul de pagini, iar cand procesul incearca sa acceseze o pagina care nu este in memoria fizica, se produce o intrerupere de tip Page Fault. SO verifica daca accesul este valid (daca exista permisiuni si daca adresa este corecta) si pagina necesarea este incarcata din stocarea secundara (hard-disk) in RAM si se actualizeaza tabela de pagini. Se reincearca instructiunea care a creat Page Fault-ul si acuma gaseste intrarea corecta in tabela de pagini.
Algoritmi de selectare a paginii: FirstInFirstOut, LastRecentlyUsed, Random Page Replacement


Vfork este o varianta a apelului traditional fork, si este utilizat pentru a crea un nou proces. Dupa un apel vfork, procesul copil partajeaza acelasi spatiu de adrese cu spatiul parinte pana cand procesul copil  apeleaza exec sau exit - procesul de copiere a spatiului de adrese poate fi costisitor deci vfork este mai eficient. Procesul parinte este suspendat panacand procesul copil termina - se evita concurenta si conflictele de acces la memorie. Vfork ajuta in cazul in care procesul copil face exec imediat pentru a incarca un nou program.

CopyOnWrite - paginile partajate sunt copiate doar atunci cand un proces incearca sa le modifice, astfel procesele pot partaja initial aceleasi pagini, dar modificarile sunt izolate per proces.

---

![[Pasted image 20250216210538.png]]

![[WhatsApp Image 2025-02-15 at 18.42.01_e4795c90.jpg]]

Inversiunea de prioritati: Fie 3 procese L, M, H (Low, Medium, High) cu prioritatile L<M<H. Procesul L incepe executia si detine o resursa partajata (de exemplu un mutex) de care are nevoie in acelasi timp procesul H. In timp ce procesul H asteapta terminarea procesului L, procesul M incepe executia si avand o prioritate mai mare fata de procesul L, acesta preia procesorul. Procesul L este blocat pana cand Procesul M termina executia, iar Procesul H este de asemenea blocat deoarece resursa necesara este detinuta de procesul L. Procesul H este blocat indirect de procesul M ceea ce este inversiunea de prioritati.
Solutie: Se ridica temporar prioritatea procesului care detine o resursa partajata la nivelul procesului cu prioritate maxima care asteapta acea resursa, sau implementarea protocoalelor de prioritate.

Conditiile necesare pentru deadlock (toate trebuiesc sa fie indeplinite simultan pentru a creea un deadlock):
- trebuie sa existe o resursa partajata care este detinuta de un anumit proces, iar un alt proces care are nevoie de acea resursa trebuie sa astepte pentru ea (mutual exclusion)
- un proces trebuie sa detina o resursa partajata si sa astepte dupa alte resurse care sunt detinute la randul lor de alte procese (hold and wait)
- o resursa partajata poate fi disponibilizata de un proces care o detine doar cu voia procesului (no preemption)
- avem procesele 1,2,...,n. Procesul 1 are nevoie de o resursa de la Procesul 2, Procesul 2 are nevoie de o resursa de la Procesul 3, ..., Procesul n are nevoie de o resursa de la Procesul 1. (circular wait)
Ultima conditie implica a doua conditie, deci cele 4 conditii nu sunt complet independente.

TLB este o structura de date de tip cache utilizata de MMU (memory management unit) ce imbunatateste viteza de convertire a unei adrese virtuale in adresa sa fizica din RAM. Acesta stocheaza o submultime a tabelului de pagini permitand accesul rapid la traducerile de adresa utilizate frecvent.
- procesorul genereaza o adresa virtuala atunci cand acceseaza memoria
- MMU cauta aceasta adresa in TLB
- Hit daca adresa este gasita in TLB si se traduce in adresa fizica rapid
- Miss daca nu este gasita in TLB, MMU trebuie sa caute in tabela de pagini din memoria principala ceea ce este mai lent
	- Dupa ce se gaseste in memoria principala, se actualizeaza si in TLB adresa respectiva

---

![[Pasted image 20250216224109.png]]

11, 1, 36, 16, 34, 9, 12

incepem de la 11
SSTF: 11, 12, 9, 16, 1, 34, 36 => seek time 1 + 3 + 7 + 15 + 33 + 2 = 61
FCFS: 11, 1, 36, 16, 34, 9, 12 => seek time 10 + 35 + 20 + 18 + 25 + 3 = 111

---

![[Pasted image 20250216225935.png]]
fara subpunctul b)
(2^10 bytes = 1KB, 2^20 bytes = 1MB, 2^30 bytes = 1GB)

- 512MB RAM
- spatiu de adrese de 47 biti -> spatiul are capacitatea de 2^47 bytes
- pagini de 16KB -> 16 x 1024 bytes -> 2^14 bytes 
- PTE de 8 bytes
- 10KB text si date incarcate la baza spatiului de adrese
- 5KB de stiva la capatul superior al spatiului de adrese

(a) cat de mare este o tabela liniara care mapeaza programul in RAM?

Numarul de pagini = (spatiu adrese) / (dimensiunea unei pagini) = 2^47 / 2^14 = 2^33 pagini
Un PTE are 8 bytes, iar noi avem 2^33 pagini => tabela liniare de pagini va ocupa 8 * 2^33 bytes 
-> 8 * 8 * 2^30 bytes = 64GB


(b)
![[WhatsApp Image 2025-02-16 at 23.55.11_e9317fe2.jpg]]


(c) descrieti o posibila implementare pentru tabela de pagini de la punctul (a) si calculati spatiul de memorie fizica necesar stocarii acestei tabele

tabele de pagini multinivel, demand paging, inverted page tables.

Detaliem tabele de pagini multinivel:

![[Pasted image 20250216233725.png]]
![[Pasted image 20250216233745.png]]
![[Pasted image 20250216233823.png]]

---

![[Pasted image 20250216234124.png]]
![[Pasted image 20250217002138.png]]

(a) & (b)

![[WhatsApp Image 2025-02-17 at 00.56.14_70300724.jpg]]