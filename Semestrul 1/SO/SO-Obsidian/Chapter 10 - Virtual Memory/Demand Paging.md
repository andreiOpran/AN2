
- Consider how an executable program might be loaded from secondary storage into memory. One option is to load the entire program in physical memory at program execution time. However, a problem with this approach is that <span style="color:rgb(112, 48, 160)">we may not initially need the entire program</span> in memory. Suppose a program starts with a list of available options from which the user is to select. Loading the entire program into memory results in loading the executable code for all options, regardless of whether or not an option is ultimately selected by the user.
- <span style="color:rgb(112, 48, 160)">An alternative strategy </span>is to load pages only as they are needed. This technique is known as <span style="color:rgb(112, 48, 160)">demand paging</span> and is commonly used in <span style="color:rgb(112, 48, 160)">virtual memory systems</span>. With demand-paged virtual memory, pages are loaded only when they are demanded during program execution. Pages that are never accessed are thus never loaded into physical memory. A demand-paging system is similar to a paging system with swapping ([[Swapping with Paging|Section 9.5.2]]) where processes reside in secondary memory (usually an HDD or NVM device). Demand paging explains one of the primary benefits of virtual memory—by loading only the portions of programs that are needed, memory is used more efficiently.

- The<span style="color:rgb(112, 48, 160)"> general concept</span> behind demand paging, as mentioned, is to load a page in memory only when it is needed. As a result, while a process is executing, some pages will be in memory, and some will be in secondary storage. Thus, we need some form of hardware support to distinguish between the two. The v<span style="color:rgb(112, 48, 160)">alid – invalid bit</span> scheme described in [[Memory Protection 3 (paging)|Section 9.3.3]] can be used for this purpose. This time, however, when the bit is set to “valid,” the associated page is both legal and in memory. If the bit is set to “invalid,” the page either is not valid (that is, not in the logical address space of the process) or is valid but is currently in secondary storage. The page-table entry for a page that is brought into memory is set as usual, but the page-table entry for a page that is not currently in memory is simply marked invalid. This situation is depicted in <span style="color:rgb(112, 48, 160)">Figure 10.4</span>. (Notice that marking a page invalid will have no effect if the process never attempts to access that page.)
- ![[Pasted image 20250214160059.png]]
- But what happens if the <span style="color:rgb(112, 48, 160)">process tries to access a page that was not brought into memory</span>? Access to a page marked invalid causes a <span style="color:rgb(112, 48, 160)">page fault</span>. The paging hardware, in translating the address through the page table, will notice that the invalid bit is set, causing a trap to the operating system. The procedure for handling this page fault is straightforward (<span style="color:rgb(112, 48, 160)">Figure 10.5</span>):
	1. We check an internal table (usually kept with the process control block) for this process to determine whether the reference was a valid or an invalid memory access. 
	2. If the reference was invalid, we terminate the process. If it was valid but we have not yet brought in that page, we now page it in. 
	3. We find a free frame (by taking one from the free-frame list, for example).
	4. We schedule a secondary storage operation to read the desired page into the newly allocated frame.
	5. When the storage read is complete, we modify the internal table kept with the process and the page table to indicate that the page is now in memory.
	6. We restart the instruction that was interrupted by the trap. The process can now access the page as though it had always been in memory.
-  ![[Pasted image 20250214160331.png]]