
- The third necessary condition for deadlocks is that there be <span style="color:rgb(112, 48, 160)">no preemption</span> of resources that have already been allocated. 
- To ensure that this condition does not hold, we can use the following <span style="color:rgb(112, 48, 160)">protocol</span>. 
	- If a thread is holding some resources and requests another resource that cannot be immediately allocated to it (that is, the <span style="color:rgb(112, 48, 160)">thread</span> <span style="color:rgb(112, 48, 160)">must</span> <span style="color:rgb(112, 48, 160)">wait</span>), then all resources the thread is currently holding are <span style="color:rgb(112, 48, 160)">preempted</span>. 
	- In other words, these resources are implicitly <span style="color:rgb(112, 48, 160)">released</span>. The <span style="color:rgb(112, 48, 160)">preempted</span> resources are added to the list of resources for which the thread is waiting. The thread will be restarted only when it can regain its old resources, as well as the new ones that it is requesting.
- Alternatively, if a thread requests some resources, we first check whether they are <span style="color:rgb(112, 48, 160)">available</span>. 
	- <span style="color:rgb(112, 48, 160)">If they are</span>, we <span style="color:rgb(112, 48, 160)">allocate</span> them. 
	- <span style="color:rgb(112, 48, 160)">I</span><span style="color:rgb(112, 48, 160)">f they are not</span>, we check whether they are allocated to some other thread that is waiting for additional resources. 
	- If so, we preempt the desired resources from the waiting thread and allocate them to the requesting thread. 
	- If the resources are neither available nor held by a waiting thread, the requesting thread must wait. While it is waiting, some of its resources may be preempted, but only if another thread requests them. A thread can be restarted only when it is allocated the new resources it is requesting and recovers any resources that were preempted while it was waiting.
- This protocol is often applied to resources whose state can be easily saved and restored later, such as CPU registers and database transactions. It cannot generally be applied to such resources as mutex locks and semaphores, precisely the type of resources where deadlock occurs most commonly