
- Both the first-fit and best-fit ([[Memory Allocation]]) strategies for memory allocation suffer from <span style="color:rgb(112, 48, 160)">external fragmentation</span>. As processes are loaded and removed from memory, the free memory space is broken into little pieces. External fragmentation exists when there is enough total memory space to satisfy a request but the available spaces are not contiguous: storage is fragmented into a large number of small holes. 
	- This fragmentation problem can be severe. In the worst case, we could have a block of free (or wasted) memory between every two processes. If all these small pieces of memory were in one big free block instead, we might be able to run several more processes.
- Depending on the total amount of memory storage and the average process size, external fragmentation may be a minor or a major problem. Statistical analysis of first fit, for instance, reveals that, even with some optimization, given N allocated blocks, another 0.5 N blocks will be lost to fragmentation. That is, one-third of memory may be <span style="color:rgb(112, 48, 160)">unusable</span>! This property is known as the <span style="color:rgb(112, 48, 160)">50-percent rule</span>.
- Memory fragmentation can be internal as well as external. Consider a multiple-partition allocation scheme with a hole of <span style="color:rgb(112, 48, 160)">18,464</span> bytes. Suppose that the next process requests <span style="color:rgb(112, 48, 160)">18,462 </span>bytes. If we allocate exactly the requested block, we are left with a hole of 2 bytes. The overhead to keep track of this hole will be substantially larger than the hole itself. The general approach to avoiding this problem is to <span style="color:rgb(112, 48, 160)">break the physical memory into fixed-sized blocks</span> and allocate memory in units based on block size. With this approach, <span style="color:rgb(112, 48, 160)">the memory allocated to a process may be slightly larger than the requested memory</span>. The difference between these two numbers is <span style="color:rgb(112, 48, 160)">internal</span> <span style="color:rgb(112, 48, 160)">fragmentation</span>â€”unused memory that is internal to a partition.
- <span style="color:rgb(112, 48, 160)">One solution</span> to the problem of external fragmentation is <span style="color:rgb(112, 48, 160)">compaction</span>. The goal is to shuffle the memory contents so as to place all free memory together in one large block. Compaction is not always possible, however.<span style="color:rgb(112, 48, 160)"> If relocation is static and is done at assembly or load time, compaction cannot be done</span>. <span style="color:rgb(112, 48, 160)">It is possible only if</span><span style="color:rgb(112, 48, 160)"> relocation is dynamic </span>and is done at execution time. If addresses are relocated dynamically, relocation requires only moving the program and data and then changing the base register to reflect the new base address. When compaction is possible, we must determine its cost. The simplest compaction algorithm is to move all processes toward one end of memory; all holes move in the other direction, producing one large hole of available memory. This scheme can be <span style="color:rgb(112, 48, 160)">expensive</span>.
- <span style="color:rgb(112, 48, 160)">Another possible solution</span> to the <span style="color:rgb(112, 48, 160)">external-fragmentation</span> problem is to permit the logical address space of processes to be noncontiguous, thus allowing a process to be allocated physical memory wherever such memory is available. This is the strategy used in [[Paging|paging]], the most common memory-management technique for computer systems.