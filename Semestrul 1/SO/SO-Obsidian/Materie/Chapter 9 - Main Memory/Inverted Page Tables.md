
- Usually, <span style="color:rgb(112, 48, 160)">each process has an associated page table</span>. <span style="color:rgb(112, 48, 160)">The page table has one entry for each page that the process is using</span> (or one slot for each virtual address, regardless of the latter’s validity). This table representation is a natural one, since processes reference pages through the pages’ virtual addresses. The operating system must then translate this reference into a physical memory address. Since the table is sorted by virtual address, the operating system is able to calculate where in the table the associated physical address entry is located and to use that value directly. <span style="color:rgb(112, 48, 160)">One of the drawbacks of this method is that each page table may consist of millions of entries</span>. <span style="color:rgb(112, 48, 160)">These tables may consume large amounts of physical memory just to keep track of how other physical memory is being used</span>.
- <span style="color:rgb(112, 48, 160)">To solve this problem</span>, we can use an <span style="color:rgb(112, 48, 160)">inverted page table</span>. An inverted page table has one entry for each real page (or frame) of memory. Each entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns the page. Thus, only one page table is in the system, and it has only one entry for each page of physical memory.
- <span style="color:rgb(112, 48, 160)">Figure 9.18</span> shows the operation of an inverted page table. Compare it with <span style="color:rgb(112, 48, 160)">Figure 9.8</span>, which depicts a standard page table in operation.
- ![[Pasted image 20250214144500.png]]
- ![[Pasted image 20250214144453.png]]

- Inverted page tables often <span style="color:rgb(112, 48, 160)">require</span> that an <span style="color:rgb(112, 48, 160)">address-space identifier</span> ([[Translation Look-Aside Buffer - Hardware Support|Section 9.3.2]]) be stored in each entry of the page table, since the table usually contains several different address spaces mapping physical memory. 
	- Storing the address-space identifier ensures that a logical page for a particular process is mapped to the corresponding physical page frame. Examples of systems using inverted page tables include the 64-bit UltraSPARC and PowerPC.
	- <span style="color:rgb(112, 48, 160)">To illustrate</span> this method, we describe a simplified version of the inverted page table used in the IBM RT: 
		- each virtual address in the system consists of a triple: 
		- `<process-id, page-number, offset>`
	- Each inverted page-table entry is a pair where the <span style="color:rgb(112, 48, 160)">process-id</span> assumes the role of the <span style="color:rgb(112, 48, 160)">address-space identifier</span>. When a memory reference occurs, part of the virtual address, consisting of `<process-id, pagenumber>`, is presented to the memory subsystem. The inverted page table is then searched for a match. 
		- If a <span style="color:rgb(112, 48, 160)">match is found</span>—say, at entry i—then the physical address is generated. 
		- If<span style="color:rgb(112, 48, 160)"> no match is found</span>, then an illegal address access has been attempted.