
- Usually, a program resides on a disk as a binary executable file. <span style="color:rgb(112, 48, 160)">To run, the program must be brought into memory and placed within the context of a proces</span>s, where it becomes eligible for execution on an available CPU. As the process executes, it accesses instructions and data from memory. Eventually, the process terminates, and its memory is reclaimed for use by other processes.
- Most systems allow a user process to reside in any part of the physical memory. Thus, although the address space of the computer may start at 00000, the first address of the user process need not be 00000. You will see later how the operating system actually places a process in physical memory.
- In most cases, <span style="color:rgb(112, 48, 160)">a user program goes through several step</span><span style="color:rgb(112, 48, 160)">s</span>—some of which may be optional—<span style="color:rgb(112, 48, 160)">before being executed</span> (Figure 9.3). Addresses may be represented in different ways during these steps. Addresses in the source program are generally symbolic (such as the variable `count`). A compiler typically binds these symbolic addresses to relocatable addresses (such as `“14 bytes from the beginning of this module”`). The <span style="color:rgb(112, 48, 160)">linker</span> or <span style="color:rgb(112, 48, 160)">loader</span> in turn binds the relocatable addresses to absolute addresses (such as <span style="color:rgb(112, 48, 160)">74014</span>). Each binding is a mapping from one address space to another.
- ![[Pasted image 20250212224413.png]]
- Classically, the binding of instructions and data to memory addresses can be<span style="color:rgb(112, 48, 160)"> done at any step along the way</span>:
	- <span style="color:rgb(112, 48, 160)">Compile time</span>. If you know at compile time where the process will reside in memory, then <span style="color:rgb(112, 48, 160)">absolute code</span> can be generated. For example, if you know that a user process will reside starting at location R, then the generated <span style="color:rgb(112, 48, 160)">compiler code will start at that location and extend up from there</span>. If, at some later time, the starting location changes, then it will be necessary to recompile this code.
	- <span style="color:rgb(112, 48, 160)">Load time</span>. If it is not known at compile time where the process will reside in memory, then the compiler must generate<span style="color:rgb(112, 48, 160)"> relocatable code</span>. In this case, <span style="color:rgb(112, 48, 160)">final binding is delayed until load time</span>. If the starting address changes, we need only reload the user code to incorporate this changed value. 
	- <span style="color:rgb(112, 48, 160)">Execution time</span>. If the process can be moved during its execution from one memory segment to another, then<span style="color:rgb(112, 48, 160)"> binding must be delayed until run time</span>. Special hardware must be available for this scheme to work, as will be discussed in [[Logical Versus Physical Address Space]]. <span style="color:rgb(112, 48, 160)">Most operating systems use this method</span>.
- A major portion of this chapter is devoted to showing how these various bindings can be implemented effectively in a computer system and to discussing appropriate hardware support.