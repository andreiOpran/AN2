
- One of the simplest methods of allocating memory is to assign processes to variably sized partitions in memory, where each partition may contain exactly one process. In this <span style="color:rgb(112, 48, 160)">variable partition</span> scheme, the operating system keeps a table indicating which parts of memory are available and which are occupied. Initially, all memory is available for user processes and is considered one large block of available memory, <span style="color:rgb(112, 48, 160)">a hole</span>. Eventually, as you will see, memory contains a <span style="color:rgb(112, 48, 160)">set of holes</span> of various sizes.
- Figure 9.7 depicts this scheme. Initially, the memory is fully utilized, containing processes 5, 8, and 2. After process 8 leaves, there is one<span style="color:rgb(112, 48, 160)"> c</span><span style="color:rgb(112, 48, 160)">ontiguous hole</span>. Later on, process 9 arrives and is allocated memory. Then process 5 departs, resulting in two noncontiguous holes.
- ![[Pasted image 20250213005313.png]]
- What happens when <span style="color:rgb(112, 48, 160)">there isnâ€™t sufficient memory</span> to satisfy the demands of an arriving process? 
	- One option is to simply reject the process and provide an appropriate error message. 
	- Alternatively, we can place such processes into a <span style="color:rgb(112, 48, 160)">wait queue</span>. When memory is later released, the operating system checks the wait queue to determine if it will satisfy the memory demands of a waiting process.
- In general, as mentioned, the memory blocks available comprise a set of holes of various sizes scattered throughout memory. When a process arrives and needs memory, the system searches the set for a hole that is large enough for this process. If the hole is too large, it is split into two parts. One part is allocated to the arriving process; the other is returned to the set of holes. When a process terminates, it releases its block of memory, which is then placed back in the set of holes. If the new hole is adjacent to other holes, these adjacent holes are merged to form one larger hole.
	- This procedure is a particular instance of the general <span style="color:rgb(112, 48, 160)">dynamic storage allocation problem</span>, which concerns how to satisfy a request of size <span style="color:rgb(112, 48, 160)">n</span> from a list of free holes. There are many solutions to this problem. The most commonly used are:
		- <span style="color:rgb(112, 48, 160)">First</span> <span style="color:rgb(112, 48, 160)">fit</span>. Allocate the first hole that is big enough. Searching can start either at the beginning of the set of holes or at the location where the previous first-fit search ended. We can stop searching as soon as we find a free hole that is large enough.
		- <span style="color:rgb(112, 48, 160)">Best</span> <span style="color:rgb(112, 48, 160)">fit</span>. Allocate the smallest hole that is big enough. We must search the entire list, unless the list is ordered by size. This strategy produces the smallest leftover hole.
		- <span style="color:rgb(112, 48, 160)">Worst</span> <span style="color:rgb(112, 48, 160)">fit</span>. Allocate the largest hole. Again, we must search the entire list, unless it is sorted by size. This strategy produces the largest leftover hole, which may be more useful than the smaller leftover hole from a best-fit approach.