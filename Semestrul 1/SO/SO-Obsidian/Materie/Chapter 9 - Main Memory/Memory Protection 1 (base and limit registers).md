- <span style="color:rgb(112, 48, 160)">Protection of memory space</span> is accomplished by having the CPU hardware compare every address generated in user mode with the registers. Any attempt by a program executing in user mode to access operating-system memory or other users’ memory results in a <span style="color:rgb(112, 48, 160)">trap</span> to the operating system, which treats the attempt as a <span style="color:rgb(112, 48, 160)">fatal error</span> (Figure 9.2). This scheme prevents a user program from (accidentally or deliberately) modifying the code or data structures of either the operating system or other users.
- ![[Pasted image 20250212220732.png]]
- The base and limit registers can be loaded only by the operating system, which uses a special privileged instruction. Since privileged instructions can be executed only in kernel mode, and since only the operating system executes in kernel mode, <span style="color:rgb(112, 48, 160)">only the operating system can load the base and limit registers</span>. This scheme allows the operating system to change the value of the registers but prevents user programs from changing the registers’ contents.
- <span style="color:rgb(112, 48, 160)">The operating system</span>, executing in<span style="color:rgb(112, 48, 160)"> kernel mode</span>, is given <span style="color:rgb(112, 48, 160)">unrestricted access to both operating-system memory and users’ memory</span>. This provision allows the operating system to load users’ programs into users’ memory, to dump out those programs in case of errors, to access and modify parameters of system calls, to perform I/O to and from user memory, and to provide many other services. Consider, for example, that an operating system for a multiprocessing system must execute context switches, storing the state of one process from the registers into main memory before loading the next process’s context from main memory into the registers.