
- Normally, when the [[Multilevel Queue (CPU) Scheduling]] algorithm is used, processes are permanently assigned to a queue when they enter the system. If there are separate queues for foreground and background processes, for example, processes do not move from one queue to the other, since processes do not change their foreground or background nature. This setup has the advantage of low scheduling overhead, but it is <span style="color:rgb(112, 48, 160)">inflexible</span>.
- The <span style="color:rgb(112, 48, 160)">multilevel feedback queue scheduling</span> algorithm, in contrast, allows a process to move between queues. The idea is to separate processes according to the characteristics of their CPU bursts. 
	- If a process uses <span style="color:rgb(112, 48, 160)">too much CPU time</span>, it will be moved to a <span style="color:rgb(112, 48, 160)">lower-priority queue</span>. This scheme leaves I/O-bound and interactive processes—which are typically characterized by short CPU bursts —in the higher-priority queues. 
	- In addition, a process that waits too long in a lower-priority queue may be moved to a higher-priority queue. This form of <span style="color:rgb(112, 48, 160)">aging</span> prevents <span style="color:rgb(112, 48, 160)">starvation</span>.
- <span style="color:rgb(112, 48, 160)">For example</span>, consider a multilevel feedback queue scheduler with three queues, numbered from 0 to 2 (Figure 5.9). 
- ![[Pasted image 20250212162809.png]]
- The scheduler first executes all processes in queue 0. Only when queue 0 is empty will it execute processes in queue 1. Similarly, processes in queue 2 will be executed only if queues 0 and 1 are empty. A process that arrives for queue 1 will <span style="color:rgb(112, 48, 160)">preempt</span> a process in queue 2. A process in queue 1 will in turn be <span style="color:rgb(112, 48, 160)">preempted</span> by a process arriving for queue 0.
- An entering process is put in queue 0. A process in queue 0 is given a time quantum of 8 milliseconds. If it does not finish within this time, it is moved to the tail of queue 1. If queue 0 is empty, the process at the head of queue 1 is given a quantum of 16 milliseconds. If it does not complete, it is preempted and is put into queue 2. Processes in queue 2 are run on an FCFS basis but are run only when queues 0 and 1 are empty. To prevent starvation, a process that waits too long in a lower-priority queue may gradually be moved to a higher-priority queue.
- This scheduling algorithm gives highest priority to any process with a CPU burst of 8 milliseconds or less. Such a process will quickly get the CPU, finish its CPU burst, and go off to its next I/O burst. Processes that need more than 8 but less than 24 milliseconds are also served quickly, although with lower priority than shorter processes. Long processes automatically sink to queue 2 and are served in FCFS order with any CPU cycles left over from queues 0 and 1.

- In general, a multilevel feedback queue scheduler is <span style="color:rgb(112, 48, 160)">defined</span> by the following <span style="color:rgb(112, 48, 160)">parameters</span>:
	- The <span style="color:rgb(112, 48, 160)">number</span> of queues
	- The <span style="color:rgb(112, 48, 160)">scheduling</span> algorithm for each queue
	- The method used to determine when to <span style="color:rgb(112, 48, 160)">upgrade</span> a process to a higher-priority queue
	- The method used to determine when to <span style="color:rgb(112, 48, 160)">demote</span> a process to a lower-priority queue
	- The method used to determine which queue a process will enter when that process needs service
- The definition of a multilevel feedback queue scheduler makes it the most general CPU-scheduling algorithm. It can be configured to match a specific system under design. Unfortunately, it is also the most complex algorithm, since defining the best scheduler requires some means by which to select values for all the parameters.